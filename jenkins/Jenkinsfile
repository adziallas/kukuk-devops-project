pipeline {
    agent any
    
    environment {
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_USERNAME = 'andziallas'
        DOCKER_IMAGE_BACKEND = "${DOCKER_USERNAME}/kukuk-backend"
        DOCKER_IMAGE_FRONTEND = "${DOCKER_USERNAME}/kukuk-frontend"
        KUBECONFIG = credentials('kubeconfig')
        GITHUB_TOKEN = credentials('github-token')
    }
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'prod'],
            description: 'Target environment for deployment'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip running tests'
        )
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()
                    env.BUILD_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT_SHORT}"
                }
            }
        }
        
        stage('Build Backend') {
            steps {
                dir('backend') {
                    script {
                        def mavenProfile = params.ENVIRONMENT
                        sh """
                            mvn clean compile -P${mavenProfile} -DskipTests=${params.SKIP_TESTS}
                        """
                    }
                }
            }
        }
        
        stage('Build Frontend') {
            steps {
                dir('frontend') {
                    sh """
                        npm install
                        npm run build
                    """
                }
            }
        }
        
        stage('Test Backend') {
            when {
                not { params.SKIP_TESTS }
            }
            steps {
                dir('backend') {
                    sh """
                        mvn test -P${params.ENVIRONMENT}
                    """
                }
            }
            post {
                always {
                    publishTestResults testResultsPattern: 'backend/target/surefire-reports/*.xml'
                }
            }
        }
        
        stage('Test Frontend') {
            when {
                not { params.SKIP_TESTS }
            }
            steps {
                dir('frontend') {
                    sh """
                        npm test -- --coverage --watchAll=false
                    """
                }
            }
        }
        
        stage('Docker Build') {
            parallel {
                stage('Build Backend Image') {
                    steps {
                        dir('backend') {
                            script {
                                def backendImage = "${DOCKER_IMAGE_BACKEND}:${BUILD_TAG}"
                                sh """
                                    docker build -t ${backendImage} .
                                    docker tag ${backendImage} ${DOCKER_IMAGE_BACKEND}:latest
                                """
                                env.BACKEND_IMAGE = backendImage
                            }
                        }
                    }
                }
                stage('Build Frontend Image') {
                    steps {
                        dir('frontend') {
                            script {
                                def frontendImage = "${DOCKER_IMAGE_FRONTEND}:${BUILD_TAG}"
                                sh """
                                    docker build -t ${frontendImage} .
                                    docker tag ${frontendImage} ${DOCKER_IMAGE_FRONTEND}:latest
                                """
                                env.FRONTEND_IMAGE = frontendImage
                            }
                        }
                    }
                }
            }
        }
        
        stage('Docker Push') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh """
                            echo ${DOCKER_PASS} | docker login -u ${DOCKER_USER} --password-stdin
                            docker push ${BACKEND_IMAGE}
                            docker push ${DOCKER_IMAGE_BACKEND}:latest
                            docker push ${FRONTEND_IMAGE}
                            docker push ${DOCKER_IMAGE_FRONTEND}:latest
                        """
                    }
                }
            }
        }
        
        stage('Deploy to Dev') {
            when {
                params.ENVIRONMENT == 'dev'
            }
            steps {
                script {
                    sh """
                        kubectl config use-context dev-context || true
                        envsubst < k8s/backend-deployment-dev.yaml | kubectl apply -f -
                        envsubst < k8s/frontend-deployment-dev.yaml | kubectl apply -f -
                        envsubst < k8s/backend-service.yaml | kubectl apply -f -
                        envsubst < k8s/frontend-service.yaml | kubectl apply -f -
                    """
                }
            }
        }
        
        stage('Manual Approval for Production') {
            when {
                params.ENVIRONMENT == 'prod'
            }
            steps {
                script {
                    def userInput = input(
                        id: 'userInput',
                        message: 'Deploy to Production?',
                        parameters: [
                            choice(
                                choices: ['Deploy', 'Abort'],
                                description: 'Choose deployment action',
                                name: 'deploymentAction'
                            )
                        ]
                    )
                    if (userInput == 'Abort') {
                        error 'Production deployment aborted by user'
                    }
                }
            }
        }
        
        stage('Deploy to Prod') {
            when {
                params.ENVIRONMENT == 'prod'
            }
            steps {
                script {
                    sh """
                        kubectl config use-context prod-context || true
                        envsubst < k8s/backend-deployment-prod.yaml | kubectl apply -f -
                        envsubst < k8s/frontend-deployment-prod.yaml | kubectl apply -f -
                        envsubst < k8s/backend-service.yaml | kubectl apply -f -
                        envsubst < k8s/frontend-service.yaml | kubectl apply -f -
                    """
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    def environment = params.ENVIRONMENT
                    def namespace = environment
                    
                    sh """
                        kubectl wait --for=condition=available --timeout=300s deployment/kukuk-backend -n ${namespace}
                        kubectl wait --for=condition=available --timeout=300s deployment/kukuk-frontend -n ${namespace}
                    """
                    
                    // Get service URLs
                    sh """
                        echo "Backend Service URL:"
                        kubectl get service kukuk-backend -n ${namespace} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "ClusterIP: \$(kubectl get service kukuk-backend -n ${namespace} -o jsonpath='{.spec.clusterIP}')"
                        echo "Frontend Service URL:"
                        kubectl get service kukuk-frontend -n ${namespace} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "ClusterIP: \$(kubectl get service kukuk-frontend -n ${namespace} -o jsonpath='{.spec.clusterIP}')"
                    """
                }
            }
        }
    }
    
    post {
        always {
            // Clean up Docker images
            sh """
                docker rmi ${BACKEND_IMAGE} || true
                docker rmi ${FRONTEND_IMAGE} || true
            """
        }
        success {
            echo 'Pipeline completed successfully!'
            // Send notification to Slack/Teams if configured
        }
        failure {
            echo 'Pipeline failed!'
            // Send failure notification
        }
        cleanup {
            cleanWs()
        }
    }
}